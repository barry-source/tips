1、迭代器模式： 提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示
优点： 
    分离 了 集合对象 的 遍历行为 ; 抽象出了 迭代器 负责 集合对象的遍历 , 可以让外部的代码 透明的 访问集合内部的数据 ;
    
缺点：
类的个数成对增加 ; 迭代器模式 , 将 存储数据 , 遍历数据 两个职责拆分 ; 如果新添加一个 集合类 , 需要增加该 集合类 对应的 迭代器类 , 类的个数成对增加 , 在一定程度上 , 增加了系统复杂性

示例：swift for in,  oc : enumberator

2、简单工厂模式：小早商场的密码加减法弹窗  用叫静态工厂模式

优点：客户端不需要修改代码。
缺点：当需要增加新的运算类的时候，不仅需新加运算类，还要修改工厂类，违反了开闭原则
类簇：
    封装一组具体的私有类，对外提供一个公共的抽象接口。
    
优点：
    用户方便易用，不需要记太多的名字，内部可以根据具体类型而做些特殊操作，就算增加私有类，也不影响外部使用
    

3、工厂模式：

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

优点：克服了简单工厂违背开放-封闭原则的缺点，又保留了封装对象创建过程的优点,降低客户端和工厂的耦合性，所以说“工厂模式”是“简单工厂模式”的进一步抽象和推广。

缺点：每增加一个产品，相应的也要增加一个子工厂，加大了额外的开发量。

4、抽象工厂模式：
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象

缺点：每增加一个产品，就必须更换接口

5、单例模式
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

优点：
    1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例
    2、避免对资源的多重占用（比如写文件操作）。
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

7、策略模式

    定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换
    
优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。
缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。

8、观察者模式
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新

优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。
缺点： 
1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 
3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

9、代理模式

为其他对象提供一种代理以控制对这个对象的访问。

优点： 1、职责清晰。 2、高扩展性。 3、智能化。
缺点： 
1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 
2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

10、 适配器模式

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。
缺点：
 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 
 
 旧view有一个model ，但是不希望引入其它的Model ,模型之间的转换
 
 
 11、命令模式
 将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。

优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。
缺点：使用命令模式可能会导致某些系统有过多的具体命令类。
 
12、空对象模式

在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。

